/**
 * @file   ReadoutUnitStats.cpp
 * @author Simon Voigt Nesbo
 * @date   November 20, 2017
 * @brief  ReadoutUnitStats member functions for analyzing
 *         statistics for ReadoutUnit generated by
 *         Alpide Dataflow SystemC simulation.
 *
 */


#include "ReadoutUnitStats.hpp"
#include <sstream>
#include <fstream>
#include <iostream>
#include <cstdlib>
#include <algorithm>

#include "TCanvas.h"
#include "TROOT.h"
#include "TProfile.h"
#include "TH2F.h"
#include "TH1F.h"
#include "TStyle.h"
#include "TFile.h"
#include "TDirectory.h"


ReadoutUnitStats::ReadoutUnitStats(unsigned int layer, unsigned int stave,
                                   unsigned int event_rate_khz, const char* path)
  : mLayer(layer)
  , mStave(stave)
  , mEventRateKhz(event_rate_khz)
  , mSimDataPath(path)
{
  std::stringstream ss_file_path_base;
  ss_file_path_base << path << "/" << "RU_" << layer << "_" << stave;

  readTrigActionsFile(ss_file_path_base.str());
  readBusyEventFiles(ss_file_path_base.str());
  readProtocolUtilizationFile(ss_file_path_base.str());
  calcDataRates();
}


void ReadoutUnitStats::readTrigActionsFile(std::string file_path_base)
{
  std::stringstream ss_filename;
  ss_filename  << file_path_base << "_trigger_actions.dat";
  std::string filename = ss_filename.str();

  std::cout << "Opening file: " << filename << std::endl;
  std::ifstream ru_stats_file(filename.c_str(), std::ios_base::in | std::ios_base::binary);

  if(!ru_stats_file.is_open()) {
    std::cerr << "Error opening file " << filename << std::endl;
    exit(-1);
  }

  uint64_t num_triggers;
  uint8_t num_ctrl_links;

  std::cout << "sizeof(uint8_t): " << sizeof(uint8_t) << std::endl;

  ru_stats_file.read((char*)&num_triggers, sizeof(num_triggers));
  ru_stats_file.read((char*)&num_ctrl_links, sizeof(num_ctrl_links));

  mNumTriggers = num_triggers;
  mNumCtrlLinks = num_ctrl_links;

  std::cout << "Num triggers: " << num_triggers << std::endl;
  std::cout << "Num links: " << mNumCtrlLinks << std::endl;

  mTrigSentCoverage.resize(num_triggers);
  mTrigSentExclFilteringCoverage.resize(num_triggers);
  mTriggerActions.resize(num_triggers);

  uint64_t trigger_id = 0;
  uint8_t trig_action = 0;
  uint64_t unknown_trig_action_count = 0;

  // Read trigger action byte, one per link, for each trigger ID,
  // and calculate coverage etc.
  while(trigger_id < num_triggers && ru_stats_file.good()) {
    uint8_t coverage = 0;
    uint8_t links_filtered = 0;

    for(unsigned int link_id = 0; link_id < num_ctrl_links; link_id++) {
      ru_stats_file.read((char*)&trig_action, sizeof(uint8_t));
      //mTriggerActions[trigger_id][link_id] = trig_action;
      mTriggerActions[trigger_id].push_back(trig_action);

      std::cout << "Trigger " << trigger_id;
      std::cout << ": RU" << mLayer << "." << mStave << ": ";

      switch(trig_action) {
      case TRIGGER_SENT:
        std::cout << "TRIGGER_SENT" << std::endl;
        coverage++;
        //links_included++;
        break;

      case TRIGGER_NOT_SENT_BUSY:
        std::cout << "TRIGGER_NOT_SENT_BUSY" << std::endl;
        //links_included++;
        break;

      case TRIGGER_FILTERED:
        std::cout << "TRIGGER_FILTERED" << std::endl;
        links_filtered++;
        break;
      default:
        // This should never happen
        std::cout << "UNKNOWN" << std::endl;
        unknown_trig_action_count++;
        break;
      }
    }

    mTrigSentCoverage[trigger_id] = (double)coverage/num_ctrl_links;
    mTrigSentExclFilteringCoverage[trigger_id] = (double)(coverage+links_filtered)/num_ctrl_links;

    mTrigSentMeanCoverage += mTrigSentCoverage[trigger_id];
    mTrigSentExclFilteringMeanCoverage += mTrigSentExclFilteringCoverage[trigger_id];

    std::cout << "Trigger " << trigger_id << std::endl;
    std::cout << "Coverage: " << mTrigSentCoverage[trigger_id] << std::endl;
    std::cout << "Coverage excluding filtered triggers: "<< mTrigSentExclFilteringCoverage[trigger_id] << std::endl;

    // Keep a record of those triggers that were filtered for some, but not all control links
    if(links_filtered != 0 && links_filtered != num_ctrl_links)
      mTriggerMismatch.push_back(trigger_id);

    trigger_id++;
  }

  mTrigSentMeanCoverage /= mNumTriggers;
  mTrigSentExclFilteringMeanCoverage /= mNumTriggers;

  if(trigger_id != num_triggers) {
    std::cerr << "Error reading " << num_triggers << ", got only " << trigger_id << std::endl;
    exit(-1);
  }

  std::cout << "Number of unknown trigger actions: " << unknown_trig_action_count << std::endl;

  std::cout << "Links with filter mismatch: ";
  for(auto it = mTriggerMismatch.begin(); it != mTriggerMismatch.end(); it++) {
    if(it == mTriggerMismatch.begin())
       std::cout << *it;
    else
      std::cout << ", " << *it;
  }
  std::cout << std::endl;
}


///@brief Reads the RUs busy event files, and initializes LinkStats objects for each link
///       found with the various busy event data.
///       Expects readTrigActionsFile() to have been called first, because the
///       mTrigSentCoverage vector needs to have been set up for some of the calculations here.
///@todo  Should have added a function for reading the busyv/flush/ro_abort/fatal
///       event files, since they all share the same format, but that required
///       some structural changes and I was too lazy to do it..
///@param file_path_base Path to simulation run data directory
void ReadoutUnitStats::readBusyEventFiles(std::string file_path_base)
{
  std::stringstream ss_busy_events;
  std::stringstream ss_busyv_events;
  std::stringstream ss_flush_events;
  std::stringstream ss_abort_events;
  std::stringstream ss_fatal_events;

  ss_busy_events  << file_path_base << "_busy_events.dat";
  ss_busyv_events << file_path_base << "_busyv_events.dat";
  ss_flush_events << file_path_base << "_flush_events.dat";
  ss_abort_events << file_path_base << "_ro_abort_events.dat";
  ss_fatal_events << file_path_base << "_fatal_events.dat";

  std::string busy_events_filename = ss_busy_events.str();
  std::string busyv_events_filename = ss_busyv_events.str();
  std::string flush_events_filename = ss_flush_events.str();
  std::string abort_events_filename = ss_abort_events.str();
  std::string fatal_events_filename = ss_fatal_events.str();

  std::cout << "Opening file: " << busy_events_filename << std::endl;
  std::ifstream busy_file(busy_events_filename, std::ios_base::in | std::ios_base::binary);

  if(!busy_file.is_open()) {
    std::cerr << "Error opening file " << busy_events_filename << std::endl;
    exit(-1);
  }

  std::cout << "Opening file: " << busyv_events_filename << std::endl;
  std::ifstream busyv_file(busyv_events_filename, std::ios_base::in | std::ios_base::binary);

  if(!busyv_file.is_open()) {
    std::cerr << "Error opening file " << busyv_events_filename << std::endl;
    exit(-1);
  }

  std::cout << "Opening file: " << flush_events_filename << std::endl;
  std::ifstream flush_file(flush_events_filename, std::ios_base::in | std::ios_base::binary);

  if(!flush_file.is_open()) {
    std::cerr << "Error opening file " << flush_events_filename << std::endl;
    exit(-1);
  }

  std::cout << "Opening file: " << abort_events_filename << std::endl;
  std::ifstream abort_file(abort_events_filename, std::ios_base::in | std::ios_base::binary);

  if(!abort_file.is_open()) {
    std::cerr << "Error opening file " << abort_events_filename << std::endl;
    exit(-1);
  }

  std::cout << "Opening file: " << fatal_events_filename << std::endl;
  std::ifstream fatal_file(fatal_events_filename, std::ios_base::in | std::ios_base::binary);

  if(!fatal_file.is_open()) {
    std::cerr << "Error opening file " << fatal_events_filename << std::endl;
    exit(-1);
  }

  uint8_t num_data_links_busy_file = 0;
  uint8_t num_data_links_busyv_file = 0;
  uint8_t num_data_links_flush_file = 0;
  uint8_t num_data_links_abort_file = 0;
  uint8_t num_data_links_fatal_file = 0;

  busy_file.read((char*)&num_data_links_busy_file, sizeof(uint8_t));
  busyv_file.read((char*)&num_data_links_busyv_file, sizeof(uint8_t));
  flush_file.read((char*)&num_data_links_flush_file, sizeof(uint8_t));
  abort_file.read((char*)&num_data_links_abort_file, sizeof(uint8_t));
  fatal_file.read((char*)&num_data_links_fatal_file, sizeof(uint8_t));

  if(num_data_links_busy_file != num_data_links_busyv_file ||
     num_data_links_busy_file != num_data_links_flush_file ||
     num_data_links_busy_file != num_data_links_abort_file ||
     num_data_links_busy_file != num_data_links_fatal_file)
  {
    std::cerr << "Error: number of data links in busy/busyv/flush/abort/fatal ";
    std::cerr << "files does not match." << std::endl;
    exit(-1);
  }

  std::cout << std::endl << std::endl;
  std::cout << "Number of data links: ";
  std::cout << int(num_data_links_busy_file);
  std::cout << std::endl;
  std::cout << "-------------------------------------------------" << std::endl;


  // Iterate through data for each link
  for(uint8_t link_count = 0; link_count < num_data_links_busy_file; link_count++) {

    std::cout << "Data link " << int(link_count) << std::endl;

    // Add a new LinkStats entry
    mLinkStats.emplace_back(mLayer, mStave, link_count);

    // Number of busy events for this link
    uint64_t num_busy_events = 0;
    busy_file.read((char*)&num_busy_events, sizeof(uint64_t));


    //--------------------------------------------------------------------------
    // Read busy event file
    //--------------------------------------------------------------------------

    // Iterate through busy events for this link
    for(uint64_t event_count = 0; event_count < num_busy_events; event_count++) {
      BusyTime busy_time;
      uint64_t busy_on_trigger = 0;
      uint64_t busy_off_trigger = 0;

      busy_file.read((char*)&busy_time.mStartTimeNs, sizeof(uint64_t));
      busy_file.read((char*)&busy_time.mEndTimeNs, sizeof(uint64_t));

      busy_time.mBusyTimeNs = busy_time.mEndTimeNs - busy_time.mStartTimeNs;

      // Keep track of busy time for all links, as well as for individual links (below)
      mAllBusyTime.push_back(busy_time.mBusyTimeNs);

      busy_file.read((char*)&busy_on_trigger, sizeof(uint64_t));
      busy_file.read((char*)&busy_off_trigger, sizeof(uint64_t));

      // Add entry with data about when the link went busy,
      // and when it went out of busy, for this busy event
      mLinkStats.back().mBusyTime.push_back(busy_time);

      uint64_t trigger_id = busy_on_trigger;

      // Add an entry for each trigger that was within the busy interval
      // (regardless of for "how long" the busy was for a specific trigger)
      // The preceding trigger that led to the busy event is also counted in here
      do {
        mLinkStats.back().mBusyTriggers.push_back(trigger_id);
        trigger_id++;
      } while(trigger_id < busy_off_trigger);

      // Keep track of busy trigger lengths per link, and for all links
      mLinkStats.back().mBusyTriggerLengths.push_back(1 + (busy_off_trigger-busy_on_trigger));
      mAllBusyTriggerLengths.push_back(1 + (busy_off_trigger-busy_on_trigger));

      std::cout << "Busy event " << event_count << std::endl;
      std::cout << "\tBusy on time: " << busy_time.mStartTimeNs << std::endl;
      std::cout << "\tBusy off time: " << busy_time.mEndTimeNs << std::endl;
      std::cout << "\tBusy time: " << busy_time.mBusyTimeNs << std::endl;

      std::cout << "\tBusy on trigger: " << busy_on_trigger << std::endl;
      std::cout << "\tBusy off trigger: " << busy_off_trigger << std::endl;
    }


    //--------------------------------------------------------------------------
    // Read busy violation event file
    //--------------------------------------------------------------------------

    // Number of busy violation events for this link
    uint64_t num_busyv_events = 0;
    busyv_file.read((char*)&num_busyv_events, sizeof(uint64_t));

    std::cout << "Number of busyv events: " << num_busyv_events << std::endl;

    uint64_t busyv_sequence_count = 0;

    // Resize vector and initialize each element to number of data links
    mTrigReadoutCoverage.resize(mNumTriggers, num_data_links_busyv_file);
    mTrigReadoutExclFilteringCoverage.resize(mNumTriggers, num_data_links_busyv_file);

    // Iterate through busy violation events for this link
    for(uint64_t event_count = 0; event_count < num_busyv_events; event_count++) {
      uint64_t busyv_trigger_id = 0;

      busyv_file.read((char*)&busyv_trigger_id, sizeof(uint64_t));

      // Subtract one link per trigger id, for each busyv event
      mTrigReadoutCoverage[busyv_trigger_id]--;
      mTrigReadoutExclFilteringCoverage[busyv_trigger_id]--;

      // If this is not the first busy violation event, calculate how
      // many triggers since the previous busy violation, and calculate
      // lengths of busy violation sequences
      if(event_count > 0) {
        uint64_t prev_busyv_trigger = mLinkStats.back().mBusyVTriggers.back();
        uint64_t busyv_distance = busyv_trigger_id - prev_busyv_trigger;

        // Keep track of busyv distances per link, and for all links
        mLinkStats.back().mBusyVTriggerDistances.push_back(busyv_distance);
        mAllBusyVTriggerDistances.push_back(busyv_distance);

        if(busyv_sequence_count > 0 && busyv_distance > 1) {
          // Keep track of busyv sequences per link, and for all links
          mLinkStats.back().mBusyVTriggerSequences.push_back(busyv_sequence_count);
          mAllBusyVTriggerSequences.push_back(busyv_sequence_count);

          busyv_sequence_count = 0;
        }
      }

      busyv_sequence_count++;

      mLinkStats.back().mBusyVTriggers.push_back(busyv_trigger_id);

      std::cout << "Busy violation event " << event_count << std::endl;
      std::cout << "\tTrigger id: " << busyv_trigger_id << std::endl ;
    }

    if(busyv_sequence_count > 0) {
      // Keep track of busyv sequences per link, and for all links
      mLinkStats.back().mBusyVTriggerSequences.push_back(busyv_sequence_count);
      mAllBusyVTriggerSequences.push_back(busyv_sequence_count);
    }


    //--------------------------------------------------------------------------
    // Read flushed incomplete event file
    //--------------------------------------------------------------------------

    // Number of busy violation events for this link
    uint64_t num_flush_events = 0;
    flush_file.read((char*)&num_flush_events, sizeof(uint64_t));

    std::cout << "Number of flushed incomplete events: ";
    std::cout << num_flush_events << std::endl;

    uint64_t flush_sequence_count = 0;

    // Iterate through flushed incomplete events for this link
    for(uint64_t event_count = 0; event_count < num_flush_events; event_count++) {
      uint64_t flush_trigger_id = 0;

      flush_file.read((char*)&flush_trigger_id, sizeof(uint64_t));

      // Subtract one link per trigger id, for each flush event
      mTrigReadoutCoverage[flush_trigger_id]--;
      mTrigReadoutExclFilteringCoverage[flush_trigger_id]--;

      // If this is not the first flushed incomplete event, calculate how
      // many triggers since the previous flushed event, and calculate
      // lengths of flushed incomplete sequences
      if(event_count > 0) {
        uint64_t prev_flush_trigger = mLinkStats.back().mFlushTriggers.back();
        uint64_t flush_distance = flush_trigger_id - prev_flush_trigger;

        // Keep track of flush incomplete distances per link, and for all links
        mLinkStats.back().mFlushTriggerDistances.push_back(flush_distance);
        mAllFlushTriggerDistances.push_back(flush_distance);

        if(flush_sequence_count > 0 && flush_distance > 1) {
          // Keep track of flush incomplete sequences per link and for all links
          mLinkStats.back().mFlushTriggerSequences.push_back(flush_sequence_count);
          mAllFlushTriggerSequences.push_back(flush_sequence_count);

          flush_sequence_count = 0;
        }
      }

      flush_sequence_count++;

      mLinkStats.back().mFlushTriggers.push_back(flush_trigger_id);

      std::cout << "Flushed incomplete event " << event_count << std::endl;
      std::cout << "\tTrigger id: " << flush_trigger_id << std::endl ;
    }


    //--------------------------------------------------------------------------
    // Read readout abort event file
    //--------------------------------------------------------------------------

    // Number of readout abort events for this link
    uint64_t num_abort_events = 0;
    abort_file.read((char*)&num_abort_events, sizeof(uint64_t));

    std::cout << "Number of readout abort events: ";
    std::cout << num_abort_events << std::endl;

    uint64_t abort_sequence_count = 0;

    // Iterate through flushed incomplete events for this link
    for(uint64_t event_count = 0; event_count < num_abort_events; event_count++) {
      uint64_t abort_trigger_id = 0;

      abort_file.read((char*)&abort_trigger_id, sizeof(uint64_t));

      // Subtract one link per trigger id, for each readout abort event
      mTrigReadoutCoverage[abort_trigger_id]--;
      mTrigReadoutExclFilteringCoverage[abort_trigger_id]--;

      // If this is not the first readout abort event, calculate how
      // many triggers since the readout abort event, and calculate
      // lengths of readout abort sequences
      if(event_count > 0) {
        uint64_t prev_abort_trigger = mLinkStats.back().mAbortTriggers.back();
        uint64_t abort_distance = abort_trigger_id - prev_abort_trigger;

        // Keep track of readout abort distances per link, and for all links
        mLinkStats.back().mAbortTriggerDistances.push_back(abort_distance);
        mAllAbortTriggerDistances.push_back(abort_distance);

        if(abort_sequence_count > 0 && abort_distance > 1) {
          // Keep track of abort sequences per link and for all links
          mLinkStats.back().mAbortTriggerSequences.push_back(abort_sequence_count);
          mAllAbortTriggerSequences.push_back(abort_sequence_count);

          abort_sequence_count = 0;
        }
      }

      abort_sequence_count++;

      mLinkStats.back().mAbortTriggers.push_back(abort_trigger_id);

      std::cout << "Readout abort event " << event_count << std::endl;
      std::cout << "\tTrigger id: " << abort_trigger_id << std::endl ;
    }


    //--------------------------------------------------------------------------
    // Read fatal event file
    //--------------------------------------------------------------------------

    // Number of fatal events for this link
    uint64_t num_fatal_events = 0;
    fatal_file.read((char*)&num_fatal_events, sizeof(uint64_t));

    std::cout << "Number of fatal events: ";
    std::cout << num_fatal_events << std::endl;

    uint64_t fatal_sequence_count = 0;

    // Iterate through fatal events for this link
    for(uint64_t event_count = 0; event_count < num_fatal_events; event_count++) {
      uint64_t fatal_trigger_id = 0;

      fatal_file.read((char*)&fatal_trigger_id, sizeof(uint64_t));

      // Subtract one link per trigger id, for each fatal event
      mTrigReadoutCoverage[fatal_trigger_id]--;
      mTrigReadoutExclFilteringCoverage[fatal_trigger_id]--;

      // If this is not the first fatal event, calculate how
      // many triggers since the last fatal event, and calculate
      // lengths of fatal sequences
      if(event_count > 0) {
        uint64_t prev_fatal_trigger = mLinkStats.back().mFatalTriggers.back();
        uint64_t fatal_distance = fatal_trigger_id - prev_fatal_trigger;

        // Keep track of fatal distances per link, and for all links
        mLinkStats.back().mFatalTriggerDistances.push_back(fatal_distance);
        mAllFatalTriggerDistances.push_back(fatal_distance);

        if(fatal_sequence_count > 0 && fatal_distance > 1) {
          // Keep track of fatal sequences per link and for all links
          mLinkStats.back().mFatalTriggerSequences.push_back(fatal_sequence_count);
          mAllFatalTriggerSequences.push_back(fatal_sequence_count);

          fatal_sequence_count = 0;
        }
      }

      fatal_sequence_count++;

      mLinkStats.back().mFatalTriggers.push_back(fatal_trigger_id);

      std::cout << "Fatal event " << event_count << std::endl;
      std::cout << "\tTrigger id: " << fatal_trigger_id << std::endl ;
    }
  } // iterate through each data link


  // Finish calculation of readout trigger coverage
  for(uint64_t trig_id = 0; trig_id < mNumTriggers; trig_id++) {
    mTrigReadoutCoverage[trig_id] -= (1 - mTrigSentCoverage[trig_id]) * num_data_links_busyv_file;
    mTrigReadoutCoverage[trig_id] /= num_data_links_busyv_file;

    mTrigReadoutExclFilteringCoverage[trig_id] -=
      (1 - mTrigSentExclFilteringCoverage[trig_id]) * num_data_links_busyv_file;

    mTrigReadoutExclFilteringCoverage[trig_id] /= num_data_links_busyv_file;

    mTrigReadoutMeanCoverage += mTrigReadoutCoverage[trig_id];
    mTrigReadoutExclFilteringMeanCoverage += mTrigReadoutExclFilteringCoverage[trig_id];
  }

  mTrigReadoutMeanCoverage /= mNumTriggers;
  mTrigReadoutExclFilteringMeanCoverage += mNumTriggers;
}


///@brief Read and parse CSV file with protocol utilization stats.
///       Must be called after readBusyEventFiles(), because it needs to know
///       how many links to expect.
void ReadoutUnitStats::readProtocolUtilizationFile(std::string file_path_base)
{
  if(mLinkStats.empty()) {
    std::cout << "ReadoutUnitStats::readProtocolUtilizationFile(): called without";
    std::cout << " initializing LinkStats objects first." << std::endl;
    exit(-1);
  }

  unsigned int num_data_links = mLinkStats.size();


  std::stringstream ss_prot_util;

  ss_prot_util  << file_path_base << "_Link_utilization.csv";

  std::string prot_util_filename = ss_prot_util.str();

  std::cout << "Opening file: " << prot_util_filename << std::endl;
  std::ifstream prot_util_file(prot_util_filename, std::ios_base::in);

  if(!prot_util_file.is_open()) {
    std::cerr << "Error opening file " << prot_util_filename << std::endl;
    exit(-1);
  }

  std::string csv_header;
  std::getline(prot_util_file, csv_header);

  if(csv_header.length() == 0) {
    std::cout << "ReadoutUnitStats::readProtocolUtilizationFile(): ";
    std::cout << "Error reading or empty CSV header read." << std::endl;
    exit(-1);
  }

  unsigned int index = 0;
  while(csv_header.length() > 0) {
    size_t end_of_field_pos = csv_header.find(";");
    std::string header_field = csv_header.substr(0, end_of_field_pos);
    mProtocolUtilization[header_field] = 0;
    mProtUtilIndex[index] = header_field;

    std::cout << "Found field: " << header_field << std::endl;

    // Remove the current field, accounting for both with
    // or without semicolon at the end
    if(end_of_field_pos == std::string::npos)
      csv_header = "";
    else
      csv_header = csv_header.substr(csv_header.find(";")+1);

    index++;
  }


  for(unsigned int link_count = 0; link_count < num_data_links; link_count++) {
    if(prot_util_file.good() == false) {
      std::cout << "ReadoutUnitStats::readProtocolUtilizationFile(): CSV file not ";
      std::cout << "good before " << num_data_links << "links have been read." << std::endl;
    }

    mLinkStats[link_count].mProtUtilIndex = mProtUtilIndex;

    unsigned int index = 0;
    std::string csv_line;
    std::getline(prot_util_file, csv_line);

    while(csv_line.length() > 0) {
      size_t end_of_field_pos = csv_line.find(";");
      std::string value_str = csv_line.substr(0, end_of_field_pos);
      std::string field = mProtUtilIndex[index];

      // Update stats for both links, and combined stats for all links for in RU
      mLinkStats[link_count].mProtocolUtilization[field] = std::stoul(value_str);;
      mProtocolUtilization[field] += std::stoul(value_str);;

      // Remove the current field, accounting for both with
      // or without semicolon at the end
      if(end_of_field_pos == std::string::npos)
        csv_line = "";
      else
        csv_line = csv_line.substr(csv_line.find(";")+1);

      index++;

      if(index > 30)
        exit(-1);
    }

    if(index != mProtUtilIndex.size()) {
      std::cout << "Incorrect number of fields on line " << link_count+1;
      std::cout << " in file " << prot_util_filename << std::endl;
      exit(-1);
    }
  }


  std::cout << std::endl << std::endl;
  std::cout << "Printing link utilization stats - totals:" << std::endl;
  std::cout << "-----------------------------------------" << std::endl;

  for(auto it = mProtUtilIndex.begin(); it != mProtUtilIndex.end(); it++) {
    std::cout << it->second << ": " << mProtocolUtilization[it->second] << std::endl;
  }

  std::cout << std::endl << std::endl;

  for(unsigned int link_count = 0; link_count < num_data_links; link_count++) {
    std::cout << std::endl << std::endl;
    std::cout << "Printing link utilization stats - link " << link_count << ":" << std::endl;
    std::cout << "-----------------------------------------" << std::endl;

    for(auto it = mProtUtilIndex.begin(); it != mProtUtilIndex.end(); it++) {
      std::cout << it->second << ": " << mLinkStats[link_count].mProtocolUtilization[it->second] << std::endl;
    }
    std::cout << std::endl << std::endl;
  }
}


///@brief Calculate data rates (protocol and data separately) in Mbps
void ReadoutUnitStats::calcDataRates(void)
{
  unsigned long data_bytes = mProtocolUtilization["DATA_SHORT (bytes)"];
  data_bytes += mProtocolUtilization["DATA_LONG (bytes)"];
  data_bytes += mProtocolUtilization["REGION_HEADER (bytes)"];

  unsigned long protocol_bytes = mProtocolUtilization["CHIP_HEADER (bytes)"];
  protocol_bytes += mProtocolUtilization["CHIP_TRAILER (bytes)"];
  protocol_bytes += mProtocolUtilization["CHIP_EMPTY_FRAME (bytes)"];
  protocol_bytes += mProtocolUtilization["BUSY_ON (bytes)"];
  protocol_bytes += mProtocolUtilization["BUSY_OFF (bytes)"];

  double sim_time = mNumTriggers*(1.0/(mEventRateKhz*1000));

  std::cout << "data_bytes: " << data_bytes << std::endl;
  std::cout << "protocol_bytes: " << protocol_bytes << std::endl;
  std::cout << "sim_time: " << sim_time << std::endl;

  mDataRateMbps = 8*(data_bytes/sim_time)/(1024*1024);
  mProtocolRateMbps = 8*(protocol_bytes/sim_time)/(1024*1024);

  std::cout << "mDataRateMbps: " << mDataRateMbps << std::endl;
  std::cout << "mProtocolRateMbps: " << mProtocolRateMbps << std::endl;
}


///@brief Trigger sent coverage for an individual trigger is defined as:
///       (Number of ctrl links the trigger was sent to) / Number of ctrl links
double ReadoutUnitStats::getTrigSentCoverage(uint64_t trigger_id) const
{
  return mTrigSentCoverage[trigger_id];
}


///@brief Trigger sent coverage for an individual trigger is defined as:
///       (   Number of ctrl links the trigger was sent to
///         + Number of ctrl links the trigger was filtered from
///       ) / (Number of control links)
double ReadoutUnitStats::getTrigSentExclFilteringCoverage(uint64_t trigger_id) const
{
  return mTrigSentExclFilteringCoverage[trigger_id];
}


///@brief Readout coverage for an individual trigger is defined as:
///       (   num_data_links
///         - num_links_with_busy_violation
///         - num_ctrl_link_trigger_was_issued_to x num_data_links_per_ctrl_link
///       ) / num_data_links
double ReadoutUnitStats::getTrigReadoutCoverage(uint64_t trigger_id) const
{
  return mTrigReadoutCoverage[trigger_id];
}


///@brief Readout coverage excluding trigger filter for an individual trigger is defined as:
///       (   num_data_links
///         - num_links_with_busy_violation
///         - num_ctrl_link_trigger_was_issued_to x ....
///       ) / num_data_links
double ReadoutUnitStats::getTrigReadoutExclFilteringCoverage(uint64_t trigger_id) const
{
  return mTrigReadoutExclFilteringCoverage[trigger_id];
}


void ReadoutUnitStats::plotEventMapCount(const char* h_name, const char* title,
                                         const std::vector<std::vector<uint64_t>*> &events,
                                         std::vector<unsigned int>& link_count_vec_out,
                                         bool create_png, bool create_pdf)
{
  TCanvas* c = new TCanvas();
  c->cd();

  unsigned int num_data_links = events.size();

  //----------------------------------------------------------------------------
  // Plot event map vs trigger id
  //----------------------------------------------------------------------------
  TH2D *h1 = new TH2D(Form("%s_map", h_name), Form("%s event map", title),
                      mNumTriggers,0,mNumTriggers-1,
                      num_data_links*5,-0.5,num_data_links-0.5);

  h1->GetXaxis()->SetTitle("Trigger ID");
  h1->GetYaxis()->SetTitle("Link ID");
  h1->GetYaxis()->SetNdivisions(num_data_links);

  for(unsigned int link_id = 0; link_id < events.size(); link_id++) {
    for(auto event_it = events[link_id]->begin();
        event_it != events[link_id]->end();
        event_it++)
    {
      h1->Fill(*event_it, link_id, 1);
    }
  }

  h1->SetStats(false);
  c->Update();
  h1->Write();
  h1->Draw("COL");

  if(create_png)
    c->Print(Form("%s/png/RU_%i_%i_%s_map.png",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));

  if(create_pdf)
    c->Print(Form("%s/pdf/RU_%i_%i_%s_map.pdf",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));


  //----------------------------------------------------------------------------
  // Plot event link count vs trigger id
  //----------------------------------------------------------------------------
  TH1D *h2 = h1->ProjectionX(Form("%s_links", h_name));
  h2->SetTitle(Form("%s event count", title));
  h2->GetYaxis()->SetTitle(Form("%s link count", title));
  h2->GetXaxis()->SetTitle("Trigger ID");

  h2->SetStats(false);
  c->Update();
  h2->Write();
  h2->Draw();

  if(create_png)
    c->Print(Form("%s/png/RU_%i_%i_%s_link_count.png",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));

  if(create_pdf)
    c->Print(Form("%s/pdf/RU_%i_%i_%s_link_count.pdf",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));


  link_count_vec_out.clear();

  // Make a copy of event link counts. Skip bin 0 (underflow bin)
  for(unsigned int bin_num = 1; bin_num <= mNumTriggers; bin_num++) {
    link_count_vec_out.push_back(h2->GetBinContent(bin_num));
  }

  delete h1;
  delete h2;
  delete c;
}


void ReadoutUnitStats::plotEventDistribution(const char* h_name, const char* title,
                                             const char* x_title, const char* y_title,
                                             std::vector<uint64_t> &event_distr,
                                             unsigned int num_bins,
                                             bool create_png, bool create_pdf)
{
  TCanvas* c = new TCanvas();
  c->cd();

  uint64_t max_val = 0;
  std::vector<uint64_t>::iterator max_val_it =
    std::max_element(event_distr.begin(), event_distr.end());

  // Just draw an empty plot if vector was empty
  if(max_val_it != event_distr.end())
    max_val = *max_val_it;

  TH1D *h = new TH1D(h_name, title, num_bins, 0, max_val);

  h->GetXaxis()->SetTitle(x_title);
  h->GetYaxis()->SetTitle(y_title);

  for(auto it = event_distr.begin(); it != event_distr.end(); it++)
  {
    h->Fill(*it);
  }

  gStyle->SetOptStat("men"); // mean, num entries, name
  h->SetStats(true);
  c->Update();
  h->Write();
  h->Draw();

  if(create_png)
    c->Print(Form("%s/png/RU_%i_%i_%s.png",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));
  if(create_pdf)
    c->Print(Form("%s/ppdf/RU_%i_%i_%s.pdf",
                  mSimDataPath.c_str(),
                  mLayer, mStave, h_name));

  delete h;
  delete c;
}


void ReadoutUnitStats::plotRU(bool create_png, bool create_pdf)
{
  unsigned int num_data_links = mLinkStats.size();

  TDirectory* current_dir = gDirectory;

  if(gDirectory == nullptr) {
    std::cout << "ReadoutUnitsStats::plotRU() error: gDirectory not initialized." << std::endl;
    exit(-1);
  }

  gDirectory->mkdir(Form("RU_%i", mStave));
  gDirectory->cd(Form("RU_%i", mStave));

  TCanvas* c1 = new TCanvas();
  c1->cd();

  //----------------------------------------------------------------------------
  // Plot busy map vs trigger id
  // Todo: Use sparse histogram?
  //----------------------------------------------------------------------------
  TH2D *h1 = new TH2D("h_busy_map","Busy events",
                              mNumTriggers,0,mNumTriggers-1,
                              num_data_links*5,-0.5,num_data_links-0.5);

  h1->GetXaxis()->SetTitle("Trigger ID");
  h1->GetYaxis()->SetTitle("Link ID");
  h1->GetYaxis()->SetNdivisions(num_data_links);

  std::cout << "Plotting data.. " << num_data_links << " links." << std::endl;

  for(unsigned int link_id = 0; link_id < num_data_links; link_id++) {
    for(auto busy_event_it = mLinkStats[link_id].mBusyTriggers.begin();
        busy_event_it != mLinkStats[link_id].mBusyTriggers.end();
        busy_event_it++)
    {
      h1->Fill(*busy_event_it, link_id, 1);
    }
  }

  h1->SetStats(false);
  c1->Update();
  h1->Draw("COL");
  h1->Write();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_busy_map.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_busy_map.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));


  //----------------------------------------------------------------------------
  // Plot busy link count vs trigger id
  //----------------------------------------------------------------------------
  TH1D *h2 = h1->ProjectionX("h_busy_links");
  h2->GetYaxis()->SetTitle("Busy link count");
  h2->GetXaxis()->SetTitle("Trigger ID");

  h2->SetStats(false);
  c1->Update();
  h2->Write();
  h2->Draw();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_busy_links_count.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_busy_links_count.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

  mBusyLinkCount.clear();

  // Make a copy of busy link counts. Skip bin 0 (underflow bin)
  for(unsigned int bin_num = 1; bin_num <= mNumTriggers; bin_num++) {
    mBusyLinkCount.push_back(h2->GetBinContent(bin_num));
  }


  //----------------------------------------------------------------------------
  // Plot busyv/flush/abort/fatal maps and link counts vs trigger id
  //----------------------------------------------------------------------------

  std::vector<std::vector<uint64_t>*> busyv_vec;
  std::vector<std::vector<uint64_t>*> flush_vec;
  std::vector<std::vector<uint64_t>*> abort_vec;
  std::vector<std::vector<uint64_t>*> fatal_vec;


  for(unsigned int link_id = 0; link_id < num_data_links; link_id++) {
    busyv_vec.push_back(&mLinkStats[link_id].mBusyVTriggers);
    flush_vec.push_back(&mLinkStats[link_id].mFlushTriggers);
    abort_vec.push_back(&mLinkStats[link_id].mAbortTriggers);
    fatal_vec.push_back(&mLinkStats[link_id].mFatalTriggers);
  }

  plotEventMapCount("h_busyv", "Busy violation", busyv_vec,
                    mBusyVLinkCount, create_png, create_pdf);
  plotEventMapCount("h_flush", "Flushed incomplete", flush_vec,
                    mFlushLinkCount, create_png, create_pdf);
  plotEventMapCount("h_abort", "Readout abort", abort_vec,
                    mAbortLinkCount, create_png, create_pdf);
  plotEventMapCount("h_fatal", "Fatal mode", fatal_vec,
                    mFatalLinkCount, create_png, create_pdf);


  c1->cd();


  //----------------------------------------------------------------------------
  // Plot busy time distribution
  //----------------------------------------------------------------------------
  /* TH1D *h5 = new TH1D("h_busy_time", */
  /*                     Form("Busy time RU %i:%i", mLayer, mStave), */
  /*                     50,0,100000); */
  /* h5->GetXaxis()->SetTitle("Time [ns]"); */
  /* h5->GetYaxis()->SetTitle("Counts"); */

  /* for(auto busy_time_it = mAllBusyTime.begin(); */
  /*     busy_time_it != mAllBusyTime.end(); */
  /*     busy_time_it++) */
  /* { */
  /*   h5->Fill(*busy_time_it); */
  /* } */

  /* gStyle->SetOptStat("men"); // mean, num entries, name */
  /* h5->SetStats(true); */
  /* c1->Update(); */
  /* h5->Write(); */
  /* h5->Draw(); */

  /* if(create_png) */
  /*   c1->Print(Form("%s/png/RU_%i_%i_busy_time.png", */
  /*                  mSimDataPath.c_str(), */
  /*                  mLayer, mStave)); */
  /* if(create_pdf) */
  /*   c1->Print(Form("%s/pdf/RU_%i_%i_busy_time.pdf", */
  /*                  mSimDataPath.c_str(), */
  /*                  mLayer, mStave)); */

  //----------------------------------------------------------------------------
  // Plot busy length distribution (time)
  //----------------------------------------------------------------------------
  plotEventDistribution("h_busy_time",
                        Form("Busy time RU %i:%i", mLayer, mStave),
                        "Time [ns]", "Counts", mAllBusyTime, 100,
                        create_png, create_pdf);


  //----------------------------------------------------------------------------
  // Plot busy trigger length distribution
  //----------------------------------------------------------------------------
  plotEventDistribution("h_busy_trig_len",
                        Form("Busy trigger length RU %i:%i", mLayer, mStave),
                        "Number of triggers", "Counts", mAllBusyTriggerLengths,
                        100, create_png, create_pdf);


  //----------------------------------------------------------------------------
  // Plot busyv/flush/abort/fatal trigger distance distribution
  //----------------------------------------------------------------------------
  plotEventDistribution("h_busyv_distance",
                        Form("Busy violation distances RU %i:%i", mLayer, mStave),
                        "BusyV trigger distance", "Counts", mAllBusyVTriggerDistances,
                        100, create_png, create_pdf);

  plotEventDistribution("h_flush_distance",
                        Form("Flushed incomplete distances RU %i:%i", mLayer, mStave),
                        "Flush incompl. trigger distance", "Counts", mAllFlushTriggerDistances,
                        100, create_png, create_pdf);

  plotEventDistribution("h_abort_distance",
                        Form("Readout abort distances RU %i:%i", mLayer, mStave),
                        "Readout abort trigger distance", "Counts", mAllAbortTriggerDistances,
                        100, create_png, create_pdf);

  plotEventDistribution("h_fatal_distance",
                        Form("Fatal mode distances RU %i:%i", mLayer, mStave),
                        "Fatal trigger distance", "Counts", mAllFatalTriggerDistances,
                        100, create_png, create_pdf);


  //----------------------------------------------------------------------------
  // Plot busyv/flush/abort/fatal trigger sequence distribution
  //----------------------------------------------------------------------------
  plotEventDistribution("h_busyv_sequence",
                        Form("Busy violation sequences RU %i:%i", mLayer, mStave),
                        "BusyV trigger sequence length", "Counts",
                        mAllBusyVTriggerSequences,
                        100, create_png, create_pdf);

  plotEventDistribution("h_flush_sequence",
                        Form("Flushed incomplete sequences RU %i:%i", mLayer, mStave),
                        "Flushed incompl. trigger sequence length", "Counts",
                        mAllFlushTriggerSequences,
                        100, create_png, create_pdf);

  plotEventDistribution("h_abort_sequence",
                        Form("Readout abort sequences RU %i:%i", mLayer, mStave),
                        "Readout abort trigger sequence length", "Counts",
                        mAllAbortTriggerSequences,
                        100, create_png, create_pdf);

  plotEventDistribution("h_fatal_sequence",
                        Form("Fatal mode sequences RU %i:%i", mLayer, mStave),
                        "Fatal trigger sequence length", "Counts",
                        mAllFatalTriggerSequences,
                        100, create_png, create_pdf);


  //----------------------------------------------------------------------------
  // Plot triggers sent coverage vs. trigger ID
  //----------------------------------------------------------------------------
  c1->cd();

  TH1D *h9 = new TH1D("h_trig_ctrl_link_coverage",
                      Form("Alpide Trigger Control Link Coverage - RU %i:%i", mLayer, mStave),
                      mNumTriggers,0,mNumTriggers-1);

  for(uint64_t trig_id = 0; trig_id < mNumTriggers; trig_id++) {
    h9->Fill(trig_id, mTrigSentCoverage[trig_id]);
  }

  h9->GetYaxis()->SetTitle("Coverage");
  h9->GetXaxis()->SetTitle("Trigger ID");
  h9->SetStats(false);
  c1->Update();
  h9->Write();
  h9->Draw();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_trig_ctrl_link_coverage.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_trig_ctrl_link_coverage.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));


  //----------------------------------------------------------------------------
  // Plot triggers sent coverage vs. trigger ID, excluding filtered triggers
  //----------------------------------------------------------------------------
  TH1D *h10 = new TH1D("h_trig_ctrl_link_excl_filter_coverage",
                       Form("Alpide Trigger Control Link Coverage Excluding Filtering - RU %i:%i", mLayer, mStave),
                       mNumTriggers,0,mNumTriggers-1);

  for(uint64_t trig_id = 0; trig_id < mNumTriggers; trig_id++) {
    h10->Fill(trig_id, mTrigSentExclFilteringCoverage[trig_id]);
  }

  h10->GetYaxis()->SetTitle("Coverage");
  h10->GetXaxis()->SetTitle("Trigger ID");
  h10->SetStats(false);
  c1->Update();
  h10->Write();
  h10->Draw();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_trig_ctrl_link_excl_filter_coverage.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_trig_ctrl_link_excl_filter_coverage.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));


  //----------------------------------------------------------------------------
  // Plot trigger readout coverage vs. trigger ID
  //----------------------------------------------------------------------------
  TH1D *h11 = new TH1D("h_trig_readout_coverage",
                       Form("Alpide Trigger Readout Coverage - RU %i:%i", mLayer, mStave),
                       mNumTriggers,0,mNumTriggers-1);

  for(uint64_t trig_id = 0; trig_id < mNumTriggers; trig_id++) {
    h11->Fill(trig_id, mTrigReadoutCoverage[trig_id]);
  }

  h11->GetYaxis()->SetTitle("Coverage");
  h11->GetXaxis()->SetTitle("Trigger ID");
  h11->SetStats(false);
  c1->Update();
  h11->Write();
  h11->Draw();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_trig_readout_coverage.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_trig_readout_coverage.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));


  //----------------------------------------------------------------------------
  // Plot trigger readout (excluding trigger filtering) coverage vs. trigger ID
  //----------------------------------------------------------------------------
  TH1D *h12 = new TH1D("h_trig_readout_excl_filter_coverage",
                       Form("Alpide Trigger Readout Coverage Excluding Filtering - RU %i:%i", mLayer, mStave),
                       mNumTriggers,0,mNumTriggers-1);

  for(uint64_t trig_id = 0; trig_id < mNumTriggers; trig_id++) {
    h12->Fill(trig_id, mTrigReadoutExclFilteringCoverage[trig_id]);
  }

  h12->GetYaxis()->SetTitle("Coverage");
  h12->GetXaxis()->SetTitle("Trigger ID");
  h12->SetStats(false);
  c1->Update();
  h12->Write();
  h12->Draw();

  if(create_png)
    c1->Print(Form("%s/png/RU_%i_%i_trig_readout_excl_filter_coverage.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  if(create_pdf)
    c1->Print(Form("%s/pdf/RU_%i_%i_trig_readout_excl_filter_coverage.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));


  //----------------------------------------------------------------------------
  // Plot link utilization histogram (counts of data word types)
  //----------------------------------------------------------------------------
  unsigned int num_fields = 0;

  // mProtocolUtilization has fields for byte counts for each data word,
  // as well as counts of each data word type (not taking size of data word into account).
  // Find out how many fields of the "count" type there are first
  for(auto prot_util_it = mProtUtilIndex.begin();
      prot_util_it != mProtUtilIndex.end();
      prot_util_it++)
  {
    std::string field_name = prot_util_it->second;
    if(field_name.find("count") != std::string::npos) {
      // Ignore COMMA, UNKNOWN and IDLE_TOTAL fields
      if(field_name.find("COMMA") == std::string::npos &&
         field_name.find("IDLE_TOTAL") == std::string::npos &&
         field_name.find("UNKNOWN") == std::string::npos) {
        num_fields++;
      }
    }
  }

  TH1D *h13 = new TH1D("h_prot_util_counts",
                       Form("Protocol utilization (counts) RU %i:%i", mLayer, mStave),
                       num_fields,
                       0.5,
                       num_fields+0.5);

  h13->GetYaxis()->SetTitle("Counts");

  unsigned int bin_index = 0;

  for(auto prot_util_it = mProtUtilIndex.begin();
      prot_util_it != mProtUtilIndex.end();
      prot_util_it++)
  {
    //unsigned int bin_index = prot_util_it->first + 1;
    std::string field_name = prot_util_it->second;
    if(field_name.find("count") != std::string::npos) {
      // Ignore COMMA, UNKNOWN and IDLE_TOTAL fields
      if(field_name.find("COMMA") == std::string::npos &&
         field_name.find("IDLE_TOTAL") == std::string::npos &&
         field_name.find("UNKNOWN") == std::string::npos) {
        // Extract name of field minus " (count)".
        std::string bin_name = field_name.substr(0, field_name.find(" (count)"));
        h13->Fill(bin_index+1, mProtocolUtilization[field_name]);
        h13->GetXaxis()->SetBinLabel(bin_index+1, bin_name.c_str());
        bin_index++;
      }
    }
  }

  // Draw labels on X axis vertically
  //h13->LabelsOption("v", "x");

  h13->SetFillColor(33);
  h13->SetStats(false);
  c1->Update();
  h13->Draw("BAR1 TEXT00");
  h13->Write();

  if(create_png) {
    c1->SetLogy(0);
    c1->Print(Form("%s/png/RU_%i_%i_prot_utilization_counts.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

    c1->SetLogy(1);
    c1->Print(Form("%s/png/RU_%i_%i_prot_utilization_counts_log.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  }
  if(create_pdf) {
    c1->SetLogy(0);
    c1->Print(Form("%s/pdf/RU_%i_%i_prot_utilization_counts.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

    c1->SetLogy(1);
    c1->Print(Form("%s/pdf/RU_%i_%i_prot_utilization_counts_log.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  }


  //----------------------------------------------------------------------------
  // Plot link utilization histogram (number of bytes per data word type)
  //----------------------------------------------------------------------------
  num_fields = 0;
  // mProtocolUtilization has fields for byte counts for each data word,
  // as well as counts of each data word type (not taking size of data word into account).
  // Find out how many fields of the "bytes" type there are first
  for(auto prot_util_it = mProtUtilIndex.begin();
      prot_util_it != mProtUtilIndex.end();
      prot_util_it++)
  {
    std::string field_name = prot_util_it->second;
    if(field_name.find("bytes") != std::string::npos) {
      // Ignore COMMA, UNKNOWN and IDLE_TOTAL fields
      if(field_name.find("COMMA") == std::string::npos &&
         field_name.find("IDLE_TOTAL") == std::string::npos &&
         field_name.find("UNKNOWN") == std::string::npos) {
        num_fields++;
      }
    }
  }

  TH1D *h14 = new TH1D("h_prot_util_bytes",
                       Form("Protocol utilization (bytes) RU %i:%i", mLayer, mStave),
                       num_fields,
                       0.5,
                       num_fields+0.5);

  h14->GetYaxis()->SetTitle("Bytes");

  bin_index = 0;

  for(auto prot_util_it = mProtUtilIndex.begin();
      prot_util_it != mProtUtilIndex.end();
      prot_util_it++)
  {
    //unsigned int bin_index = prot_util_it->first + 1;
    std::string field_name = prot_util_it->second;
    if(field_name.find("bytes") != std::string::npos) {
      // Ignore COMMA, UNKNOWN and IDLE_TOTAL fields
      if(field_name.find("COMMA") == std::string::npos &&
         field_name.find("IDLE_TOTAL") == std::string::npos &&
         field_name.find("UNKNOWN") == std::string::npos) {
        // Extract name of field minus " (bytes)".
        std::string bin_name = field_name.substr(0, field_name.find(" (bytes)"));
        h14->Fill(bin_index+1, mProtocolUtilization[field_name]);
        h14->GetXaxis()->SetBinLabel(bin_index+1, bin_name.c_str());
        bin_index++;
      }
    }
  }

  // Draw labels on X axis vertically
  //h14->LabelsOption("v", "x");

  h14->SetFillColor(33);
  h14->SetStats(false);
  c1->Update();
  h14->Draw("BAR1 TEXT00");
  h14->Write();

  if(create_png) {
    c1->SetLogy(0);
    c1->Print(Form("%s/png/RU_%i_%i_prot_utilization_bytes.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

    c1->SetLogy(1);
    c1->Print(Form("%s/png/RU_%i_%i_prot_utilization_bytes_log.png",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

  }
  if(create_pdf) {
    c1->SetLogy(0);
    c1->Print(Form("%s/pdf/RU_%i_%i_prot_utilization_bytes.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));

    c1->SetLogy(1);
    c1->Print(Form("%s/pdf/RU_%i_%i_prot_utilization_bytes_log.pdf",
                   mSimDataPath.c_str(),
                   mLayer, mStave));
  }


  //----------------------------------------------------------------------------
  // Plot link histograms
  //----------------------------------------------------------------------------
  for(unsigned int link_id = 0; link_id < num_data_links; link_id++) {
    // Keep changing back to this RU's directory,
    // because the plotLink() function changes the current directory.
    current_dir->cd(Form("RU_%i", mStave));

    mLinkStats[link_id].plotLink();
  }


  delete c1;
  delete h1;
  delete h2;
  delete h9;
  delete h10;
  delete h11;
  delete h12;
  delete h13;
  delete h14;
}
