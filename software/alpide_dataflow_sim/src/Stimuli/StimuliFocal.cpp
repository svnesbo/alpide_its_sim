/**
 * @file   StimuliFocal.cpp
 * @author Simon Voigt Nesbo
 * @date   March 7, 2019
 * @brief  Source file for Stimuli class for Focal
 */

#include "StimuliFocal.hpp"
#include "Detector/Common/DetectorSimulationStats.hpp"

// Ignore warnings about use of auto_ptr and unused parameters in SystemC library
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#include <systemc.h>
#pragma GCC diagnostic pop

#include <list>
#include <sstream>
#include <fstream>

extern volatile bool g_terminate_program;


SC_HAS_PROCESS(StimuliFocal);
///@brief Constructor for stimuli class.
///       Instantiates and initializes the event generator and Alpide objects,
///       connects the SystemC ports
///@param[in] name SystemC module name
///@param[in] settings QSettings object with simulation settings.
///@param[in] output_path Path to store output files generated by the Stimuli class
StimuliFocal::StimuliFocal(sc_core::sc_module_name name, QSettings* settings, std::string output_path)
  : StimuliBase(name, settings, output_path)
{
  if(mSingleChipSimulation) {
    std::cerr << "Error: Single chip simulation not supported for Focal." << std::endl;
    exit(-1);
  }

  std::cout << "Number of layers: ";
  std::cout << settings->value("pct/num_layers").toUInt() << std::endl;

  std::cout << "Number of staves per layer: ";
  std::cout << settings->value("pct/num_staves_per_layer").toUInt() << std::endl;

  std::cout << std::endl << std::endl;

  // Initialize detector configuration for Focal.
  // Doing it here because event generator expects this parameter,
  // though it is not used for single chip simulation
  PCT::PCTDetectorConfig config;
  config.num_layers = settings->value("pct/num_layers").toUInt();

  for(unsigned int i = 0; i < PCT::N_LAYERS; i++) {
    if(i < 2) { // Only 2 layers in Focal
      config.layer[i].num_staves = settings->value("pct/num_staves_per_layer").toUInt();
    } else {
      config.layer[i].num_staves = 0;
    }
  }

  config.chip_cfg = mChipCfg;

  mEventGen = std::move(std::unique_ptr<EventGenITS>(new EventGenITS("event_gen",
                                                                     config,
                                                                     settings,
                                                                     mOutputPath)));

  mFocal = std::move(std::unique_ptr<PCT::PCTDetector>(new PCT::PCTDetector("PCT", config,
                                                                            mTriggerFilterTimeNs,
                                                                            mTriggerFilterEnabled,
                                                                            mDataRateIntervalNs)));
  mFocal->s_system_clk_in(clock);
  mFocal->s_detector_busy_out(s_focal_busy);

  s_physics_event = false;

  if(mContinuousMode == true) {
    SC_METHOD(continuousTriggerMethod);
  }

  SC_METHOD(stimuliMainMethod);
  sensitive << mEventGen->E_triggered_event;
  dont_initialize();

  SC_METHOD(stimuliQedNoiseEventMethod);
  sensitive << mEventGen->E_untriggered_event;
  dont_initialize();

  // This method just generates a (VCD traceable) SystemC signal
  // that coincides with the physics event from the event generator
  SC_METHOD(physicsEventSignalMethod);
  sensitive << mEventGen->E_triggered_event;
  dont_initialize();
}


///@brief Main control of simulation stimuli
void StimuliFocal::stimuliMainMethod(void)
{
  if(simulation_done == true || g_terminate_program == true) {
    int64_t time_now = sc_time_stamp().value();
    std::cout << "@ " << time_now << " ns: \tSimulation done" << std::endl;

    sc_core::sc_stop();

    writeStimuliInfo();

    if(mSingleChipSimulation)
      Detector::writeAlpideStatsToFile(mOutputPath,
                                       mAlpide->getChips(),
                                       &PCT::PCT_global_chip_id_to_position);
    else
      mFocal->writeSimulationStats(mOutputPath);

    mEventGen->writeSimulationStats(mOutputPath);
  }
  // We want to stop at n_events, not n_events-1.
  else if(mEventGen->getTriggeredEventCount() <= mNumEvents) {
    //if((mEventGen->getPhysicsEventCount() % 100) == 0) {
    int64_t time_now = sc_time_stamp().value();
    std::cout << "@ " << time_now << " ns: \tPhysics event number ";
    std::cout << mEventGen->getTriggeredEventCount() << std::endl;
    //}

    std::cout << "Feeding " << mEventGen->getTriggeredEvent().size() << " pixels to ITS detector." << std::endl;
    // Get hits for this event, and "feed" them to the ITS detector
    auto event_hits = mEventGen->getTriggeredEvent();

    if(mSingleChipSimulation) {
      for(auto it = event_hits.begin(); it != event_hits.end(); it++)
        mAlpide->pixelInput(*it);

      std::cout << "Creating event for next trigger.." << std::endl;

      if(mContinuousMode == false) {
        // Create an event for the next trigger, delayed by the
        // total/specified trigger delay (to account for cable/CTP delays etc.)
        mReadoutUnit->E_trigger_in.notify(mTriggerDelayNs, SC_NS);
      }
    }
    else {
      for(auto it = event_hits.begin(); it != event_hits.end(); it++)
        mFocal->pixelInput(*it);

      std::cout << "Creating event for next trigger.." << std::endl;

      if(mContinuousMode == false) {
      // Create an event for the next trigger, delayed by the
      // total/specified trigger delay (to account for cable/CTP delays etc.)
        mFocal->E_trigger_in.notify(mTriggerDelayNs, SC_NS);
      }
    }

    if(mEventGen->getTriggeredEventCount() == mNumEvents) {
      // When we have reached the desired number of events, allow simulation to run for
      // another X us to allow readout of data remaining in MEBs, FIFOs etc.
      next_trigger(100, SC_US);
      simulation_done = true;
      mEventGen->stopEventGeneration();
    } else {
      next_trigger(mEventGen->E_triggered_event);
    }
  }
}


///@brief SystemC method for feeding QED and noise events that are
///       not associated with a trigger to the ALPIDE chips.
void StimuliFocal::stimuliQedNoiseEventMethod(void)
{
    // Get hits for this event, and "feed" them to the ITS detector
    auto event_hits = mEventGen->getUntriggeredEvent();

    if(mSingleChipSimulation) {
      for(auto it = event_hits.begin(); it != event_hits.end(); it++)
        mAlpide->pixelInput(*it);
    }
    else {
      for(auto it = event_hits.begin(); it != event_hits.end(); it++)
        mFocal->pixelInput(*it);
    }
}


///@brief SystemC method for generating triggers in continuous mode
void StimuliFocal::continuousTriggerMethod(void)
{
  if(mSingleChipSimulation)
    mReadoutUnit->E_trigger_in.notify(mTriggerDelayNs, SC_NS);
  else
    mFocal->E_trigger_in.notify(mTriggerDelayNs, SC_NS);

  next_trigger(mStrobeActiveNs+mStrobeInactiveNs, SC_NS);
}


///@brief This SystemC method just toggles the s_physics_event for a clock cycle
///       signal every time we get an E_triggered_event from the event generator,
///       so that we can have a signal for this that we can add to the trace file.
void StimuliFocal::physicsEventSignalMethod(void)
{
  if(s_physics_event.read() == true) {
    s_physics_event.write(false);
    next_trigger(mEventGen->E_triggered_event);
  } else {
    s_physics_event.write(true);
    next_trigger(25,SC_NS);
  }
}


///@brief Add SystemC signals to log in VCD trace file.
///@param[in,out] wf VCD waveform file pointer
void StimuliFocal::addTraces(sc_trace_file *wf) const
{
  sc_trace(wf, s_physics_event, "PHYSICS_EVENT");
  sc_trace(wf, s_focal_busy, "its_busy");

  if(mSingleChipSimulation) {
    sc_trace(wf, s_alpide_data_line, "alpide_data_line");
    mAlpide->addTraces(wf, "");
  } else {
    mFocal->addTraces(wf, "");
  }
}


void StimuliFocal::writeStimuliInfo(void) const
{
  std::string info_filename = mOutputPath + std::string("/simulation_info.txt");
  ofstream info_file(info_filename);

  if(!info_file.is_open()) {
    std::cerr << "Error opening simulation info file: " << info_filename << std::endl;
    return;
  }

  info_file << "Number of triggered events requested: " << mNumEvents << std::endl;
  info_file << "Number of triggered events simulated: ";
  info_file << mEventGen->getTriggeredEventCount() << std::endl;

  info_file << "Number of untriggered events requested: " << 0 << std::endl;
  info_file << "Number of untriggered events simulated: ";
  info_file << mEventGen->getUntriggeredEventCount() << std::endl;
}
