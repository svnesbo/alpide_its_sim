/**
 * @file   Stimuli.cpp
 * @author Simon Voigt Nesbo
 * @date   December 12, 2016
 * @brief  Source file for stimuli function for Alpide Dataflow SystemC model
 */

#include "Stimuli.hpp"

// Ignore warnings about use of auto_ptr in SystemC library
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#include <systemc.h>
#pragma GCC diagnostic pop

#include <list>
#include <sstream>
#include <fstream>

extern volatile bool g_terminate_program;

void print_event_rate(const std::list<int>& t_delta_queue);


SC_HAS_PROCESS(Stimuli);
///@brief Constructor for stimuli class.
///       Instantiates and initializes the EventGenerator and Alpide objects,
///       connects the SystemC ports
///@param[in] name SystemC module name
///@param[in] settings QSettings object with simulation settings.
///@param[in] output_path Path to store output files generated by the Stimuli class
Stimuli::Stimuli(sc_core::sc_module_name name, QSettings* settings, std::string output_path)
  : sc_core::sc_module(name)
  , s_strobe_n("strobe_n", false)
{
  mOutputPath = output_path;

  // Initialize variables for Stimuli object
  mNumEvents = settings->value("simulation/n_events").toInt();
  mSingleChipSimulation = settings->value("simulation/single_chip").toBool();
  mContinuousMode = settings->value("simulation/continuous_mode").toBool();
  mStrobeActiveNs = settings->value("event/strobe_active_length_ns").toInt();
  mStrobeInactiveNs = settings->value("event/strobe_inactive_length_ns").toInt();
  mTriggerDelayNs = settings->value("event/trigger_delay_ns").toInt();

  // Instantiate event generator object
  mEventGen = new EventGenerator("event_gen", settings, mOutputPath);

  if(mSingleChipSimulation) {
    ///@todo Implement single chip simulation
    // mAlpideChip = new Alpide("alpide",
    //                          i,
    //                          region_fifo_size,
    //                          dmu_fifo_size,
    //                          dtu_delay,
    //                          enable_clustering,
    //                          mContinuousMode,
    //                          matrix_readout_speed);

    // mAlpideChips->s_system_clk_in(clock);
    // mAlpideChips->s_strobe_n_in(s_strobe_n);
    // mAlpideChips->s_chip_ready_out(s_chip_ready[i]);
    // mAlpideChips->s_serial_data_output(s_alpide_serial_data[i]);
  } else {
    detectorConfig config;
    config.layer[0].num_stave = settings->value("its/layer0_num_staves").toInt();
    config.layer[1].num_stave = settings->value("its/layer1_num_staves").toInt();
    config.layer[2].num_stave = settings->value("its/layer2_num_staves").toInt();
    config.layer[3].num_stave = settings->value("its/layer3_num_staves").toInt();
    config.layer[4].num_stave = settings->value("its/layer4_num_staves").toInt();
    config.layer[5].num_stave = settings->value("its/layer5_num_staves").toInt();
    config.layer[6].num_stave = settings->value("its/layer6_num_staves").toInt();

    mITS = new ITSDetector("ITS", config);
    mITS->s_system_clk_in(clock);
    mITS->E_trigger_in(E_CTP_trigger);
    mITS->s_detector_busy_out(s_its_busy);

    mCTP = new CTP("CTP");
    mCTP->E_physics_trigger_in(E_physics_trigger);
    mCTP->E_trigger_delayed_out(E_CTP_trigger);
  }


  // Connect SystemC signals to EventGenerator
  mEventGen->E_event_frame_available(E_event_frame_available);
  mEventGen->s_physics_event_out(s_physics_event);

  int region_fifo_size = settings->value("alpide/region_fifo_size").toInt();
  int dmu_fifo_size = settings->value("alpide/dmu_fifo_size").toInt();
  int dtu_delay = settings->value("alpide/dtu_delay").toInt();
  bool enable_clustering = settings->value("alpide/clustering_enable").toBool();
  bool matrix_readout_speed = settings->value("alpide/matrix_readout_speed_fast").toBool();

  s_physics_event = false;

  SC_METHOD(stimuliMainMethod);
  sensitive << E_physics_event;

  SC_METHOD(physicsEventSignalMethod);
  sensitive << E_physics_event;
}


///@brief Main control of simulation stimuli
void Stimuli::stimuliMainMethod(void)
{
  if(simulation_done == false && g_terminate_program == false) {
    sc_core::sc_stop();
    writeDataToFile();
  }
  else if(mEventGen->getPhysicsEventCount() < mNumEvents) {
    if((mEventGen->getPhysicsEventCount() % 100) == 0) {
      int64_t time_now = sc_time_stamp().value();
      std::cout << "@ " << time_now << " ns: \tPhysics event number ";
      std::cout << mEventGen->getPhysicsEventCount() << std::endl;
    }

    PhysicsEvent& event = mEventGen->getPhysicsEvent();
    event.feedToDetector(mITS);

    // Notify CTP that there was a physics event
    E_physics_trigger.notify();
    next_trigger(E_physics_event);
  }
  else {
    // After all strobes have been generated, or upon CTRL+C, allow simulation
    // to run for another X us to allow readout of data remaining in MEBs, FIFOs etc.
    next_trigger(10, SC_US);
    simulation_done = true;
  }
}


///@brief This SystemC method just toggles the s_physics_event for a clock cycle
///       signal every time we get an E_physics_event from the event generator,
///       so that we can have a signal for this that we can add to the trace file.
void Stimuli::physicsEventSignalMethod(void)
{
  if(s_physics_event.read() == true) {
    s_physics_event.write(false);
    next_trigger(E_physics_event);
  } else {
    s_physics_event.write(true);
    next_trigger(25,SC_NS);
  }
}


///@brief Add SystemC signals to log in VCD trace file.
///@param[in,out] wf VCD waveform file pointer
void Stimuli::addTraces(sc_trace_file *wf) const
{
  sc_trace(wf, s_strobe_n, "STROBE_N");
  sc_trace(wf, s_physics_event, "PHYSICS_EVENT");

  // Add traces for all Alpide chips
  for(auto it = mAlpideChips.begin(); it != mAlpideChips.end(); it++) {
    (*it)->addTraces(wf, "");
  }
}


///@brief Write simulation data to file. Histograms for MEB usage from the Alpide chips,
///       and event frame statistics (number of accepted/rejected) in the chips are recorded here
void Stimuli::writeDataToFile(void) const
{
  std::vector<std::map<unsigned int, std::uint64_t> > alpide_histos;
  unsigned int all_histos_biggest_key = 0;

  std::string csv_filename = mOutputPath + std::string("/MEB_size_histograms.csv");
  ofstream csv_file(csv_filename);

  if(!csv_file.is_open()) {
    std::cerr << "Error opening CSV file for histograms: " << csv_filename << std::endl;
    return;
  }

  csv_file << "Multi Event Buffers in use";

  // Get histograms from chip objects, and finish writing CSV header
  for(auto it = mAlpideChips.begin(); it != mAlpideChips.end(); it++) {
    int chip_id = (*it)->getChipId();
    csv_file << ";Chip ID " << chip_id;

    alpide_histos.push_back((*it)->getMEBHisto());

    // Check and possibly update the biggest MEB size (key) found in the histograms
    auto current_histo = alpide_histos.back();
    if(current_histo.rbegin() != current_histo.rend()) {
      unsigned int current_histo_biggest_key = current_histo.rbegin()->first;
      if(all_histos_biggest_key < current_histo_biggest_key)
        all_histos_biggest_key = current_histo_biggest_key;
    }
  }

  // Write values to CSV file
  for(unsigned int MEB_size = 0; MEB_size <= all_histos_biggest_key; MEB_size++) {
    csv_file << std::endl;
    csv_file << MEB_size;

    for(unsigned int i = 0; i < alpide_histos.size(); i++) {
      csv_file << ";";

      auto histo_it = alpide_histos[i].find(MEB_size);

      // Write value if it was found in histogram
      if(histo_it != alpide_histos[i].end())
        csv_file << histo_it->second;
      else
        csv_file << 0;
    }
  }


  std::string event_frame_stats_filename = mOutputPath + std::string("/event_frame_stats.csv");
  ofstream event_frame_stats_file(event_frame_stats_filename);

  event_frame_stats_file << "Chip ID; Accepted event frames; Rejected event frames" << std::endl;
  for(auto it = mAlpideChips.begin(); it != mAlpideChips.end(); it++) {
    event_frame_stats_file << (*it)->getChipId() << ";";
    event_frame_stats_file << (*it)->getEventFramesAcceptedCount() << ";";
    event_frame_stats_file << (*it)->getEventFramesRejectedCount() << std::endl;
  }


  std::string info_filename = mOutputPath + std::string("/simulation_info.txt");
  ofstream info_file(info_filename);

  if(!info_file.is_open()) {
    std::cerr << "Error opening simulation info file: " << csv_filename << std::endl;
    return;
  }

  info_file << "Number of physics events requested: " << mNumEvents << std::endl;
  info_file << "Number of physics events simulated: " << mEventGen->getPhysiscsEventCount() << std::endl;
}


///@brief Takes a list of t_delta values (time between events) for the last events,
///       calculates the average event rate over those events, and prints it to std::cout.
///       The list must be maintained by the caller.
///@todo  Update/fix/remove this function.. currently not used..
void print_event_rate(const std::list<int>& t_delta_queue)
{
  long t_delta_sum = 0;
  double t_delta_avg;
  long event_rate;

  if(t_delta_queue.size() == 0) {
    event_rate = 0;
  } else {
    for(auto it = t_delta_queue.begin(); it != t_delta_queue.end(); it++) {
      t_delta_sum += *it;
    }

    std::cout << "t_delta_sum: " << t_delta_sum << " ns" << std::endl;
    t_delta_avg = t_delta_sum/t_delta_queue.size();
    std::cout << "t_delta_avg: " << t_delta_avg << " ns" << std::endl;

    t_delta_avg /= 1.0E9;

    std::cout << "t_delta_avg: " << t_delta_avg << " s" << std::endl;

    event_rate = 1/t_delta_avg;
  }

  std::cout << "Average event rate: " << event_rate << "Hz" << std::endl;;
}
