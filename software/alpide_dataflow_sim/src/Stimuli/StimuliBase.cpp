/**
 * @file   StimuliBase.cpp
 * @author Simon Voigt Nesbo
 * @date   November 19, 2018
 * @brief  Source file for stimuli base class for Alpide Dataflow SystemC model
 */

#include "StimuliBase.hpp"
#include <iostream>

///@brief Constructor for stimuli base class.
///@param[in] settings QSettings object with simulation settings.
///@param[in] output_path Path to store output files generated by the StimuliBase class
StimuliBase::StimuliBase(sc_core::sc_module_name name,
                         QSettings* settings,
                         std::string output_path)
  : sc_core::sc_module(name)
{
  mOutputPath = output_path;

  // Initialize variables for StimuliBase object
  mNumEvents = settings->value("simulation/n_events").toULongLong();
  mSingleChipSimulation = settings->value("simulation/single_chip").toBool();
  mSystemContinuousMode = settings->value("simulation/system_continuous_mode").toBool();
  mSystemContinuousPeriodNs = settings->value("simulation/system_continuous_period_ns").toUInt();
  mStrobeActiveNs = settings->value("event/strobe_active_length_ns").toUInt();
  mStrobeInactiveNs = settings->value("event/strobe_inactive_length_ns").toUInt();
  mTriggerDelayNs = settings->value("event/trigger_delay_ns").toUInt();
  mTriggerFilterTimeNs = settings->value("event/trigger_filter_time_ns").toUInt();
  mTriggerFilterEnabled = settings->value("event/trigger_filter_enable").toBool();
  mDataRateIntervalNs = settings->value("data_output/data_rate_interval_ns").toUInt();

  mChipCfg.dtu_delay_cycles = settings->value("alpide/dtu_delay").toUInt();
  mChipCfg.strobe_length_ns = mStrobeActiveNs;
  mChipCfg.min_busy_cycles = settings->value("alpide/minimum_busy_cycles").toUInt();
  mChipCfg.strobe_extension = settings->value("alpide/strobe_extension_enable").toBool();
  mChipCfg.data_long_en = settings->value("alpide/data_long_enable").toBool();
  mChipCfg.chip_continuous_mode = settings->value("alpide/chip_continuous_mode").toBool();
  mChipCfg.matrix_readout_speed = settings->value("alpide/matrix_readout_speed_fast").toBool();

  if((mStrobeActiveNs+mStrobeInactiveNs) > mSystemContinuousPeriodNs) {
    std::string error_msg = "Alpide strobe active + inactive time > system continuous period.";
    throw std::runtime_error(error_msg);
  }

  std::cout << std::endl;
  std::cout << "-------------------------------------------------" << std::endl;
  std::cout << "Simulation settings:" << std::endl;
  std::cout << "-------------------------------------------------" << std::endl;
  std::cout << "Number of events: " << mNumEvents << std::endl;
  std::cout << "Single chip simulation: " << (mSingleChipSimulation ? "true" : "false") << std::endl;
  std::cout << "System continuous mode: " << (mSystemContinuousMode ? "continuous" : "triggered") << std::endl;
  std::cout << "System continuous period: " << mSystemContinuousPeriodNs << std::endl;
  std::cout << "Chip continuous mode: " << (mChipCfg.chip_continuous_mode ? "continuous" : "triggered") << std::endl;
  std::cout << "Strobe active time (ns): " << mStrobeActiveNs << std::endl;
  std::cout << "Strobe inactive time (ns): " << mStrobeInactiveNs << std::endl;
  std::cout << "Trigger delay (ns): " << mTriggerDelayNs << std::endl;
  std::cout << "Trigger filter time (ns): " << mTriggerFilterTimeNs << std::endl;
  std::cout << "Trigger filter enabled: " << (mTriggerFilterEnabled ? "true" : "false") << std::endl;
  std::cout << "DTU delay (clock cycles): " << mChipCfg.dtu_delay_cycles << std::endl;
  std::cout << "Data long enabled: " << (mChipCfg.data_long_en ? "true" : "false") << std::endl;
  std::cout << "Matrix readout speed fast: " << (mChipCfg.matrix_readout_speed ? "true" : "false") << std::endl;
  std::cout << "Strobe extension enabled: " << (mChipCfg.strobe_extension ? "true" : "false") << std::endl;
  std::cout << "Minimum busy cycles: " << mChipCfg.min_busy_cycles << std::endl;
  std::cout << "Data rate interval (ns): " << mDataRateIntervalNs << std::endl;


  if(mDataRateIntervalNs == 0) {
    std::string error_msg = "Data rate interval can not be zero.";
    throw std::runtime_error(error_msg);
  }
}
